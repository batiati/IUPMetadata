<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Strict//EN">
<html>
<head>
<meta http-equiv="Content-Language" content="en-us">
<title>IupFlatTree</title>
<link rel="stylesheet" type="text/css" href="../../style.css">
<style type="text/css">
.style1 {
	font-size: large;
}
.style2 {
	text-align: center;
}
.style3 {
	background-color: #CEE7FF;
}
.auto-style1 {
	background-color: #FFFF00;
}
</style>
</head>
<body>
<div id="navigation">
  <ul>
    <li><a href="#Creation">Creation</a></li>
    <li><a href="#Attributes">Attributes</a></li>
    <li><a href="#Callbacks">Callbacks</a></li>
    <li><a href="#Notes">Notes</a></li>
    <li><a href="#Examples">Examples</a></li>
    <li><a href="#SeeAlso">See Also</a></li>
  </ul>
</div>

<h2>IupFlatTree <span class="style1">(since 3.29)</span></h2>
<p>Creates a tree containing nodes of branches or leaves. Both branches and 
leaves can have an associated text and image.</p>
<p>The branches can be expanded or collapsed. When a branch is expanded, its immediate children are visible, and when it 
  is collapsed they are hidden.</p>
<p>The leaves can generate an &quot;executed&quot; or &quot;renamed&quot; actions, branches can only generate 
a &quot;renamed&quot; action. 
</p>
<p>The focus node is the node with the focus rectangle, marked nodes have their background inverted. 
</p>
<p>
  It behaves like <a href="iuplist.html">IupFlatTree</a> but it does not depends on 
  the native system.</p>
<p>It inherits from
  <a href="../elem/iupcanvas.html">IupCanvas</a>.</p>


<h3><a name="Creation">Creation</a></h3>
<div>
  <pre>Ihandle* IupFlatTree(void); [in C] 
iup.flattree{} -&gt; (<strong>ih</strong>: ihandle) [in Lua]
flattree() [in LED]</pre>
</div>

  
<p>
  <u>Returns:</u> the identifier of the 
  created element, or NULL if an error occurs.</p>


<h3><a name="Attributes">Attributes</a></h3>


<p>Inherits all attributes and callbacks of the <a href="../elem/iupcanvas.html">IupCanvas</a>, 
but redefines a few attributes.</p>
<p>Different from the IupTree, all attributes are functional before map. The 
attributes marked with <sup>(*)</sup> are exclusive to the IupFlatTree and are 
NOT support in the regular IupTree.</p>
<h4><a href="iupflattree_attrib.html#global">General</a></h4>
<p class="info"><strong>AUTOREDRAW<br>
BGCOLOR<br>
BORDERCOLOR<sup>(*)</sup><br>BORDERWIDTH<sup>(*)</sup><br>COUNT<br>
EXPAND<br>EXTRATEXTWIDTH<sup>(*)</sup><br>
FGCOLOR<br>HLCOLOR</strong><sup><strong>(*)</strong></sup><strong><br class="auto-style1">
HLCOLORALPHA</strong><sup><strong>(*)</strong></sup><strong><br class="auto-style1">PSCOLOR<sup>(*)</sup><br>TEXTPSCOLOR<sup>(*)</sup><br>ICONSPACING</strong><sup><strong>(*)</strong></sup><strong><br>
INDENTATION<br>
RASTERSIZE<br>
SPACING<br>
TOPITEM</strong></p>
<h4><strong><a href="iupflattree_attrib.html#Expanders">Expanders</a></strong></h4>
<p class="info"><strong>HIDELINES<br>
HIDEBUTTONS<br>
LINECOLOR</strong><sup><strong>(*)</strong></sup><strong><br class="auto-style1">
BUTTONBGCOLOR</strong><sup><strong>(*)</strong></sup><strong><br class="auto-style1">BUTTONFGCOLOR</strong><sup><strong>(*)</strong></sup><strong><br class="auto-style1">
BUTTONBRDCOLOR</strong><sup><strong>(*)</strong></sup><strong><br class="auto-style1">BUTTONSIZE</strong><sup><strong>(*)<br>
</strong></sup><strong>BUTTONPLUSIMAGE</strong><sup><strong>(*)</strong></sup><strong><br>BUTTONMINUSIMAGE</strong><sup><strong>(*)</strong></sup></p>
<h4><a href="iupflattree_attrib.html#nodes">Nodes</a></h4>
<p class="info"><strong>CHILDCOUNT<br>
<strong style="color: rgb(0, 0, 0); font-family: tahoma, verdana, arial, helvetica, geneva, sans-serif; font-size: medium; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: 20.7999992370605px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);">
TOTALCHILDCOUNT</strong><br>
    COLOR<br>BACKCOLOR<sup>(*)</sup><br>
    ITEMTIP<sup>(*)</sup><br>DEPTH<br>
    KIND<br>
    PARENT<br>
    STATE<br>
    TITLE<br>
TITLEFONT<br>USERDATA<br>EXTRATEXT<sup>(*)</sup></strong></p>
<h4><strong><a href="iupflattree_attrib.html#Toggle">Toggle</a></strong></h4>
<p class="info"><strong>SHOWTOGGLE<br>EMPTYTOGGLE<sup>(*)</sup><br>
TOGGLEVALUE<br>TOGGLEVISIBLE<br>TOGGLEBGCOLOR</strong><sup><strong>(*)</strong></sup><strong><br class="auto-style1">TOGGLEFGCOLOR</strong><sup><strong>(*)</strong></sup><strong><br class="auto-style1">
TOGGLESIZE</strong><sup><strong>(*)</strong></sup></p>
<h4><a href="iupflattree_attrib.html#images">Images</a></h4>
<p class="info"><strong>IMAGE<br>IMAGEEXPANDED<br>IMAGELEAF<br>
    IMAGEBRANCHCOLLAPSED<br>
    IMAGEBRANCHEXPANDED<br>BACKIMAGE</strong><sup><strong>(*)</strong></sup><strong><br>BACKIMAGEZOOM</strong><sup><strong>(*)</strong></sup></p>
<h4><a href="iupflattree_attrib.html#focus">Focus</a></h4>
<p class="info"><strong>VALUE<br>CANFOCUS<br>
PROPAGATEFOCUS<br>FOCUSFEEDBACK<sup>(*)</sup><br>HASFOCUS</strong><sup><strong>(*)</strong></sup></p>
<h4><a href="iupflattree_attrib.html#marks">Marks</a></h4>
<p class="info"><strong>MARK<br>
MARKED<br>
    MARKEDNODES<br>MARKMODE<br>
MARKSTART<br>MARKWHENTOGGLE</strong></p>
<h4><a href="iupflattree_attrib.html#tree">Hierarchy</a></h4>
<p class="info"><strong>ADDEXPANDED<br>ADDLEAF<br>
    ADDBRANCH<br>
COPYNODE<br>
DELNODE<br>
</strong>
<b>EXPANDALL<br>
    </b><strong>INSERTLEAF<br>
    INSERTBRANCH<br>
MOVENODE</strong></p>
<h4><a href="iupflattree_attrib.html#edit">Editing</a></h4>
<p class="info"><b>RENAME<br>
</b> <strong>RENAMECARET<br>
    RENAMESELECTION<br>
    SHOWRENAME</strong></p>
<h4><strong><a href="iupflattree_attrib.html#DragDrop">Drag&amp;Drop</a></strong></h4>
<p class="info"><strong>DRAGDROPTREE<br>
DROPFILESTARGET<br>
DROPEQUALDRAG<br>
SHOWDRAGDROP</strong></p>
<h3><a href="iupflattree_cb.html" name="Callbacks">Callbacks</a></h3>


<p>Inherits all callbacks of the <a href="../elem/iupcanvas.html">IupCanvas</a>, 
but redefines a few of them. Including BUTTON_CB, LEAVEWINDOW_CB, FOCUS_CB, and MOTION_CB. To 
allow the application to use those callbacks the same callbacks are exported 
with the &quot;FLAT_&quot; prefix using the same parameters. They are all called before the internal callbacks and if they return 
IUP_IGNORE the internal callbacks are not processed.</p>


<p><strong>SELECTION_CB</strong>:
  Action generated when an node is selected or 
  deselected.<br>
<strong>MULTISELECTION_CB</strong>:
  Action generated when multiple nodes are 
  selected with the mouse and the shift key pressed.<br>
<strong style="color: rgb(0, 0, 0); font-family: tahoma, verdana, arial, helvetica, geneva, sans-serif; font-size: medium; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: 20.7999992370605px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);">
MULTIUNSELECTION_CB</strong><span style="color: rgb(0, 0, 0); font-family: tahoma, verdana, arial, helvetica, geneva, sans-serif; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 20.7999992370605px; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none; background-color: rgb(255, 255, 255);">: 
Action generated before multiple nodes are unselected in one single operation.</span><br>
<strong>BRANCHOPEN_CB</strong>:
  Action generated when a branch is expanded. <br>
<strong>BRANCHCLOSE_CB</strong>:
  Action generated when a branch is collapsed.<br>
<strong>EXECUTELEAF_CB:
  </strong>Action generated when a leaf is executed. <strong><br>EXECUTEBRANCH_CB:
  </strong>Action generated when a branch is  
  executed.<strong><br>
SHOWRENAME_CB</strong>:
  Action generated before a node is renamed. 
  <br>
<strong>RENAME_CB</strong>:
  Action generated after a node is renamed. <br>
<strong>DRAGDROP_CB</strong>:
  Action generated when an internal drag &amp; drop is 
  executed. <br>
<strong>NODEREMOVED_CB</strong>:
  Action generated when a node is about to be removed.<br>
<strong>RIGHTCLICK_CB</strong>:
  Action generated when the right mouse button 
  is pressed over a node.<br>
<strong>TOGGLEVALUE_CB</strong>:
  Action generated when the toggle&#39;s state was changed. The callback also 
receives the new toggle&#39;s state.<br></p>
<p>
<a href="../attrib/iup_dragdrop.html">Drag &amp; Drop</a> attributes and 
callbacks are supported, but
SHOWDRAGDROP must be set to NO.</p>



<h3><a name="Notes">Notes</a></h3>
<p><strong>IupFlatTree</strong> is almost identical to the <strong>IupTree</strong> 
with some additional attributes, but it has a major difference: <strong>all the 
attributes work before map</strong>. So you can add and remove nodes before the 
element is mapped to the native system.</p>
<p>Another important difference is that there is no ADDROOT attribute. <strong>
IupFlatTree</strong> behaves as ADDROOT=NO always, so there is never an initial 
root branch.</p>
<p>The SPACING attribute is simply the vertical space between each node, 
different from the IupTree.</p>
<p>The EMPTYTOGGLE attribute replaces EMPTYAS3STATE and it works in all systems.</p>
<p>Finally all features behave the same in all systems.</p>
<h4>Hierarchy</h4>
<p>Branches can contain other branches or leaves. 
The first node always has id=0 and depth=0. The tree nodes have a sequential identification number 
  (id), starting by the first, with id=0, and increases for each node independent 
from the node depth. The following picture illustrates the numbering of the nodes 
in a tree.</p>
<p class="style2">
<img src="images/iuptree.png"><br>
<strong>Tree nodes and Ids</strong></p>
<p>Since you have to add each node the creation of this tree can be done in 
several ways because the action attributes ADD* and INSERT* use an existent node 
to position the new node. The following pseudo code initializes the tree from top to 
bottom sequentially:</p>
<pre>
TITLE0 = "Figures"
  ADDLEAF0 = "Other"    // Use the previous node as reference
  ADDBRANCH1 = "triangle"
    ADDLEAF2 = "equilateral"
    ADDLEAF3 = "isoceles"
    ADDLEAF4 = "scalenus"
  INSERTBRANCH2 = "parallelogram"  // Use the previous node at the same depth as reference
    ADDLEAF6 = "square"
    ADDLEAF7 = "diamond"
  INSERTBRANCH6 = "2D"
  INSERTBRANCH9 = "3D"
</pre>
<p>The following pseudo code initializes the tree from bottom to top 
sequentially (except for branches), and also uses the focus node:</p>
<pre>
VALUE = 0  // Set the focus node at the first (default for a new element)
TITLE = "Figures"
ADDBRANCH = "3D"
ADDBRANCH = "2D"
ADDBRANCH = "parallelogram"
ADDLEAF1 = "diamond"
ADDLEAF1 = "square"
ADDBRANCH = "triangle"
ADDLEAF1 = "scalene"
ADDLEAF1 = "isosceles"
ADDLEAF1 = "equilateral"
ADDLEAF = "Other"
</pre>
<p>Notice that in both cases the initialization of the tree is highly dependent 
on the order of the operations.</p>
<p>Scrollbars are automatically displayed if the tree is greater than its 
display area.</p>
<p>The first node added to an empty tree will always be the focus node.</p>
<p>Branches may be added in IupLua using a Lua Table, see 
<a href="#TreeAddNodes">iup.TreeAddNodes</a>.&nbsp; </p>
<h4>Manipulation</h4>
<p>Node insertion or removal is done by means 
  of attributes. It is allowed to remove nodes and branches inside callbacks associated to opening or closing branches.
  </p>
<p>This means that the user may insert nodes and branches only when necessary 
when the parent branch is opened, allowing the use of a larger IupFlatTree without 
too much overhead. Then when the parent branch is closed the subtree can be 
removed. But the subtree must have at least 1 node so the branch can be opened 
and closed, empty branches can NOT be opened.</p>
<h4>User Data</h4>
<p>The node id does not always correspond to the same 
  node as the tree is modified. For example, an id=2 will always refer to the third node in the tree, 
so if you add a node before the third node, the node with id=2 will now refer to 
the new node, and the old node will now have id=3. For that 
  reason, each node can store an user data pointer uniquely identifying the 
node. To set or retrieve the user data of a node use the <strong>USERDATAid</strong> 
attribute, or the <strong><a href="#Extra_Functions">Extra Functions</a></strong> 
below to associate a user data to a node and to find a node given its user data.</p>
<h4>Images</h4>
<p>IupFlatTree has three types of images: one associated to the leaf, one to the collapsed branch and 
  the other to the expanded branch. Each image can be changed, both globally and individually.</p>
<p>The predefined images used in IupFlatTree can be obtained by means of function IupGetHandle. The names of the 
  predefined images are: IMGLEAF, IMGCOLLAPSED, IMGEXPANDED, IMGBLANK (blank sheet of paper) and 
  IMGPAPER (written sheet of paper). By default:</p>
<pre>&quot;IMAGELEAF&quot; uses &quot;IMGLEAF&quot;
&quot;IMAGEBRANCHCOLLAPSED&quot; uses &quot;IMGCOLLAPSED&quot;
&quot;IMAGEBRANCHEXPANDED&quot; uses &quot;IMGEXPANDED&quot;</pre>
<pre>&quot;IMGBLANK&quot; and &quot;IMGPAPER&quot; are designed for use as &quot;IMAGELEAF&quot;</pre>
<p>The default images are 16x16 pixels on standard resolution and 24x24 pixels 
on high resolution (4k displays), but you can force the use of the high 
resolution images by defining the global attribute &quot;TREEIMAGE24&quot; to &quot;Yes&quot;.</p>
<p>All imagens do NOT need to have 
the same size, but it is recommended that a pair of branch open and branch 
collapsed to have the same size.</p>
<p>IMGEMPTY can be used as branches or leafs to clear the image (a totally 
transparent image).</p>
<h4>Simple Marking</h4>
<p>It is the default operation mode (MARKMODE=SINGLE). In this mode only one node can 
be selected.</p>
<h4>Multiple Marking</h4>
<p>IupFlatTree allows marking several nodes simultaneously using the Shift and Control keys. To use 
  multiple marking set MARKMODE=MULTIPLE. Multiple nodes can 
also be selected using mouse dragging if SHOWDRAGDROP=NO.</p>
<p>When a user keeps the Control key pressed, 
  the individual marking mode is used. This way, the focus node can be modified without changing the marked node. To 
  reverse a node marking, the user simply has to press the space bar.</p>
<p>When the user keeps the Shift key pressed, 
  the block marking mode is used. This way, all nodes between the focus node and the initial node are marked, and all 
  others are unmarked. The initial node is changed every time a node is marked without the Shift key being pressed. This 
  happens when any movement is done without Shift or Control keys being pressed, or when the space bar is pressed together 
  with Control.</p>
<h4>Extra Text Area (since 3.30)</h4>
<p>The extra text area is displayed when EXTRATEXTWIDTH is greater than 0. It is 
located at right, and displays additional text associated with each node. The 
split handler can be controlled by the user and directly sets the EXTRATEXTWIDTH 
attribute.</p>
<h4><a name="navigation">Navigation</a></h4>
<p>Using the keyboard: </p>
<ul>
  <li><b>Arrow Up/Down</b>: Moves the focus node to the neighbor 
    node, according to the arrow direction. If <strong>Shift</strong> is pressed 
  and MARKMODE=MULTIPLE a continuous range of cells is selected.</li>
  <li><b>Home/End</b>: Moves the focus node to the first/last node.</li>
  <li><b>Page Up/Page Down</b>: Moves the focus node to the node one visible page above/below the 
    focus node.</li>
  <li><b>Enter</b>: If the focus node is an expanded branch, it is collapsed; if it is a collapsed
    branch, it is expanded; if it is a leaf, it is executed.</li>
	<li><b>Ctrl+Arrow Up/Down</b>: Moves only the 
	focus node.</li>
  <li><b>Ctrl+Space</b>:&nbsp;Marks or unmark the node at focus.</li>
	<li><strong>F2</strong>: Calls the rename callback or invoke the in place 
	rename.</li>
	<li><strong>Esc</strong>: cancels in place rename.</li>
</ul>
<p>Using the left mouse button: </p>
<ul>
  <li><b>Clicking a node</b>: Moves the focus node to the clicked node.</li>
  <li><b>Clicking a (-/+) box</b>: Makes the branch to the right of the (-/+) 
    box collapse/expand.</li>
  <li><b>Double-clicking a node</b>: 
	Moves the focus node to the clicked node. If the node is an expanded 
    branch, it is collapsed; if it is a collapsed branch, it is expanded; if it is a leaf, it is executed. 
  </li>
  <li><b>Clicking twice a node</b>: Calls the rename callback 
    or invoke the in place rename.</li>
	<li><strong>Clicking and dragging a node</strong>: if SHOWDRAGDROP=Yes 
	starts a drag. When mouse is released, the DRAGDROP_CB callback is called. 
	If the callback does not exist or if it returns IUP_CONTINUE then the node is moved 
	to the new position. If Ctrl is pressed then the node is copied instead of 
	moved. In Motif drag is performed with the middle mouse 
	button.</li>
</ul>
<h4>Removing a Node with &quot;Del&quot;</h4>
<p>By default the Del key is not processed, but you can implement it using a 
simple K_ANY callback:</p>
<pre>int k_any(Ihandle* ih, int c)
{
  if (c == K_DEL) 
   IupSetAttribute(ih,&quot;DELNODE&quot;,&quot;MARKED&quot;);
  return IUP_CONTINUE;
}</pre>
<h3><a name="Extra_Functions">Extra Functions</a></h3>
<p><strong>IupFlatTree</strong> has functions that allow associating a pointer (or a user defined id) to 
  a node. In order to do that, you provide the id of the node and the pointer (userid); even 
  if the node's id changes later on, the userid will still be associated with the given node. In IupLua, instead of a 
  pointer the same functions are defined for table and userdata. These functions 
use the <strong>USERDATAid</strong> attribute.</p>
<p><strong>IupFlatTree</strong> shares the same functions with <strong>IupTree</strong>.</p>
<hr>
<pre>int IupTreeSetUserId(Ihandle *<strong>ih</strong>, int <strong>id</strong>, void *<strong>userid</strong>); [in C]
iup.TreeSetUserId(<strong>ih: </strong>ihandle, <strong>id: </strong>number, <strong>userid: </strong>userdata/table) [in Lua]
or <strong>ih</strong>:SetUserId(<strong>id: </strong>number, <strong>userid: </strong>userdata/table) [in Lua]</pre>
<p><strong>ih</strong>: Identifier of the interface element. <br>
<strong>id</strong>:
      Node identifier. <br>
<strong>userid</strong>:
      User pointer or Lua table to be associated with the node. 
      Use NULL (nil) value to remove the association.</p>
<p>Returns a non zero value if the node was found.</p>
<p>Associates an userid with a given id. If the id of the node is changed, the 
userid remains the same.</p>
<p>Associations to Lua objects in Lua 5 are referenced in the Lua REGISTRY. So they can be retrieved later. This 
      means also that the associated object will not be garbage collected until its reference is removed. Also, the user should not use the same table to reference different nodes (neither in the same nor across 
      different trees.)</p>
<p>It is similar of setting the <strong>USERDATAid</strong> attribute, but with 
the additional feature of storing the Lua object in the registry.</p>
<pre>void* IupTreeGetUserId(Ihandle *<strong>ih</strong>, int <strong>id</strong>); [in C] 
iup.TreeGetUserId(<strong>ih: </strong>ihandle, <strong>id: </strong>number) -&gt; (<b>ret:</b> userdata/table) [in Lua]
or <strong>ih</strong>:GetUserId(<strong>id: </strong>number) -&gt; (<b>ret:</b> userdata/table) [in Lua]
</pre>
<p><strong>ih</strong>: Identifier of the interface element. <br>
<strong>id</strong>:
      Node identifier.</p>
<p>Returns the pointer or Lua table associated to 
      the node or NULL if none was associated. <strong>SetUserId</strong> must 
have been called for the node with the given id.</p>
<p>It is similar of retrieving the <strong>USERDATAid</strong> attribute, but 
the Lua object is retrieved from the REGISTRY.</p>
<pre>int IupTreeGetId(Ihandle *<strong>ih</strong>, void *<strong>userid</strong>); [in C] 
iup.TreeGetId(<strong>ih: </strong>ihandle, <strong>userid: </strong>userdata/table) -&gt; (<b>ret:</b> number) [in Lua]
or <strong>ih</strong>:GetId(<strong>userid: </strong>userdata/table) -&gt; (<b>ret:</b> number) [in Lua]
</pre>
<p><strong>ih</strong>: Identifier of the interface element. <br>
<strong>userid</strong>:
      Pointer or Lua table associated to the node.</p>
<p>Returns the id of the node that has the userid on success or -1 
      (nil) if not found. <strong>SetUserId</strong> must have been called with 
the same userid.</p>
<hr>
<p>Here are some utilities exclusive for Lua. Also the same functions of the
<strong>IupTree</strong>.</p>



<pre>iup.<a name="TreeAddNodes">TreeAddNodes</a>(<strong>ih: </strong>ihandle, <strong>tree: </strong>table, [<strong>id</strong>: number]) [in Lua]
or <strong>ih:</strong><a name="TreeAddNodes0">AddNodes</a>(<strong>tree: </strong>table, [<strong>id</strong>: number]) [in Lua]</pre>
<p><strong>ih</strong>: Identifier of the interface element.<br>
<strong>tree</strong>: table of nodes.<br>
<strong>id</strong>: optional existing node. The default is the first (0).</p>
<p>Initializes the tree using the given Lua table as values for the tree nodes 
using <a href="iupflattree_attrib.html#tree">ADDBRANCH</a> and ADDLEAF (so it also 
must be done after map). For example:</p>
<pre>tree_nodes = 
{
  branchname = &quot;Figures&quot;,
  &quot;Other",
  {
    branchname = &quot;triangle&quot;,
    state = &quot;COLLAPSED&quot;,
    &quot;equilateral&quot;,
    &quot;isoceles&quot;,
    "scalenus",
  },
  {
    branchname = &quot;parallelogram&quot;,
    &quot;square&quot;,
    { leafname = &quot;diamond&quot;, color = &quot;92 92 255&quot;, titlefont = &quot;Courier, 14&quot; },
  },
  { branchname = &quot;2D&quot; },
  { branchname = &quot;3D&quot; },
}

tree = iup.tree{}
dlg = iup.dialog{tree}

dlg:map()

iup.TreeAddNodes(tree, tree_nodes)

dlg:show()</pre>
<p>Inside a table <strong>branchname</strong> defines a branch and its title,
<strong>leafname</strong> defines a leaf and its title. When a node inside a 
branch is not a table then it is a leaf and only defines the leaf title. When
<strong>leafname</strong> or <strong>branchname</strong> are used you can also 
define other node attributes: <strong>color</strong>, <strong>state</strong>,
<strong>titlefont</strong>, <strong>marked</strong>, <strong>image</strong> and
<strong>imageexpanded</strong>; without specifying the node id. You can also use
<strong>userid</strong> to associate an userdata or table just like in <strong>
iup.TreeSetUserId</strong>.</p>



<pre>iup.TreeSetNodeAttributes(<strong>ih: </strong>ihandle, <strong>id</strong>: number, <strong>attrs: </strong>table) [in Lua]
or <strong>ih:</strong>SetNodeAttributes(<strong>id</strong>: number, <strong>attrs: </strong>table) [in Lua]</pre>
<p><strong>ih</strong>: Identifier of the interface element.<br>
<strong>id</strong>: existing node.<br>
<strong>tree</strong>: table of attributes.</p>
<p>Sets a group of attributes stored in a table in the form attrs = {name = 
value, ...}.</p>
<pre>iup.TreeSetAncestorsAttributes(<strong>ih: </strong>ihandle, <strong>id</strong>: number, <strong>attrs: </strong>table) [in Lua]
or <strong>ih:</strong>SetAncestorsAttributes(<strong>id</strong>: number, <strong>attrs: </strong>table) [in Lua]</pre>
<p><strong>ih</strong>: Identifier of the interface element.<br>
<strong>id</strong>: existing node.<br>
<strong>tree</strong>: table of attributes.</p>
<p>Calls <strong>iup.TreeSetNodeAttributes</strong> for all ancestors of the 
given node (not including the node).</p>



<pre>iup.TreeSetDescendantsAttributes(<strong>ih: </strong>ihandle, <strong>id</strong>: number, <strong>attrs: </strong>table) [in Lua]
or <strong>ih:</strong>SetDescendantsAttributes(<strong>id</strong>: number, <strong>attrs: </strong>table) [in Lua]</pre>
<p><strong>ih</strong>: Identifier of the interface element.<br>
<strong>id</strong>: existing node.<br>
<strong>tree</strong>: table of attributes.</p>
<p>Calls <strong>iup.TreeSetNodeAttributes</strong> for all descendants of the 
given node (not including the node).</p>
</font>
<h3>Utility Functions </h3>
<p>These functions can be used to set and get attributes from the element:</p>
<pre>void  IupSetAttributeId(Ihandle *ih, const char* name, int id, const char* value);
char* IupGetAttribute<span class="style3">Id</span>(Ihandle *ih, const char* name, int id);
int   IupGetInt<span class="style3">Id</span>(Ihandle *ih, const char* name, int id);
float IupGetFloat<span class="style3">Id</span>(Ihandle *ih, const char* name, int id);
void  IupSetfAttribute<span class="style3">Id</span>(Ihandle *ih, const char* name, int id, const char* format, ...);
void  IupSetIntId(Ihandle* ih, const char* name, int id, int value);
void  IupSetFloatId(Ihandle* ih, const char* name, int id, float value);</pre>
<p>They work just like the respective traditional set and get functions. But the attribute string is complemented with 
  the id value. For ex:</p>
<pre>IupSetAttributeId(ih, &quot;KIND&quot;, 30, value) == IupSetAttribute(ih, &quot;KIND30&quot;, value)
IupSetAttributeId(ih, &quot;ADDLEAF&quot;, 10, value) == IupSetAttribute(ih, &quot;ADDLEAF10&quot;, value)</pre>
<p>But these functions are faster than the traditional functions because they do 
not need to parse the attribute name string and the application does not need to 
concatenate the attribute name with the id.</p>
<h3><a name="Examples">Examples</a></h3>
<p><a href="../../examples/">Browse for Example Files</a></p>
<div align="center">
  
<center>
  
<table style="border-collapse: collapse;" id="AutoNumber1" border="0" bordercolor="#111111" cellpadding="5" cellspacing="0">
<tbody>
<tr>
<th>Regular Tree</th>
</tr>
<tr>
<td class="bg_winxp"><img src="images/iupflattree1.png" border="0"></td>
</tr>
<tr>
<th>Tree with Toggle</th>
</tr>
<tr>
<td class="bg_winxp"><img src="images/iupflattree2.png" border="0"></td>
</tr>
<tr>
<th>Tree without lines and expander buttons</th>
</tr>
<tr>
<td class="bg_winxp"><img src="images/iupflattree3.png" border="0"></td>
</tr>
<tr>
<th>Tree with extra text area</th>
</tr>
<tr>
<td class="bg_winxp"><img src="images/iupflattree4.png" border="0"></td>
</tr>
</tbody>
</table>

  </center>

</div>


</body>

</html>
